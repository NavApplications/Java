Create string objects
  -> using new keyword, creates object in heap memory and stores value in string pool
  -> using string literal, stores values in string pool
 
String literal vs new
  -> string literal assigns the reference the same value if already present in string pool/new does not check
  -> intern method is used to store the string value in string pool or return the reference if the value is already present
 
String vs StringBuffer vs StringBuilder
  -> immutable/mutable/mutable
  -> thread safe/thread safe/non threadsafe

Why string is immutable and final
  -> multiple references have same value stored in string pool; any changes impacts all references
  -> avoids synchronization as it is thread safe
  -> hashcode is cached at the time of creation , which makes the ideal candidate for keys in maps

Why char array is preferred for storing passwords
  -> strings will be available in memory garbage collected/char array can be cleared once the need is complete
 
Process vs Thread
  -> self contained execution environment/single task of execution within the process
 
Daemon thread
  -> runs in background that does not stop jvm from terminating
 
Thread creation
  -> create a class that implements runnable interface and create an instance
  -> create a class that extends thread and create an instance
 
Thread lifecycle
  -> new, runnable, running, wait, dead
 
Start vs Run in a thread
  -> start will run in same thread/run will spawn a new thread
 
Thread scheduler
  -> os service that allocates the cpu time to the available runnable threads for execution
  -> implementation based on thread priority or time slicing
  -> the high priority thread gets executed first but not guaranteed
  -> time slicing technique divides the cpu time to the allocated threads based on thread priorty or long awaiting threads
 
Join
  -> blocks the execution of the thread until the specified thread completes the execution
 




  
